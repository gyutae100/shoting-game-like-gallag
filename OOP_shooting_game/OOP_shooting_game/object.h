//------------------------------------------------------------------------------
//	클래스 계층도
//
//			CObject
//		    /     |
//		 CBullet  CUnit
//				  /   |
//			CPlayer  CEnermy
//------------------------------------------------------------------------------

#pragma once

#include <iostream>
using namespace std;


//환경 설정 헤더
#include "environment_setting.h"


//클래스 선언
class CBullet;


//------------------------------------------------------------------------------
//	오브젝트 클래스
//
//	:최상위 오브젝트
//	:공통 요소 모음
//------------------------------------------------------------------------------
class CObject {

private:
	//현재 좌표
	int _x;
	int _y;


	//가시성 여부
	bool _bvisible;



protected:

	//이전 이동 좌표
	int _pre_x;
	int _pre_y;


	//오브젝트 타입
	TYPE_OBJECT _type;

	//유닛 모양
	char shape[10]; 

	//마지막 움직인 방향
	DIRECTION_MOVE _last_move_direction;

	//------------------------------------------------------------------------------
	//	가상 소멸자
	//------------------------------------------------------------------------------
	virtual ~CObject()
	{

	}

public:


	//------------------------------------------------------------------------------
	//	해당 오브젝트 파괴
	//------------------------------------------------------------------------------
	bool Destroy()
	{
		//현재 좌표 저장
		int now_x = GetX();
		int now_y = GetY();

		//전역 외부 설정
		extern CList<CObject*> g_list_object;
		extern char g_buffer[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
		extern CList<CObject*>::iterator* g_buf_iter[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];

		//출력 버퍼에서 삭제
		g_buffer[now_y][now_x] = '\0';

		//해당 이터레이터 저장
		CList<CObject*>::iterator *ptr_current_iter = g_buf_iter[now_y][now_x];

		//오브젝트 리스트에서 해당 이터레이터 삭제
		g_list_object.erase(*ptr_current_iter);

		//해당 오브젝트 삭제
		delete(this);

		return true;
	}

	//------------------------------------------------------------------------------
	//	생성자
	//------------------------------------------------------------------------------
	CObject(int x, int y, bool bvisible)
	{
		_last_move_direction = DIRECTION_MOVE::MOVE_STOP;

		_x = x;
		_y = y;
		_bvisible = bvisible;

		_type = C_OBJECT;
	}


	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스1
	//
	//	:불렛 클래스에서 이용 시 
	//------------------------------------------------------------------------------
	virtual bool  Action() = 0;

	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스2
	//
	//	플레이어 클래스와 에너미 클래스에서 이용 시
	//------------------------------------------------------------------------------
	virtual bool Action(CBullet **out_make_bullet) = 0;



	//------------------------------------------------------------------------------
	//	움직이는 방향 반환
	//------------------------------------------------------------------------------
	DIRECTION_MOVE GetDirectionMove() {
		return _last_move_direction;
	}



	//------------------------------------------------------------------------------
	//	해당 오브젝트 타입 반환
	//------------------------------------------------------------------------------
	TYPE_OBJECT GetType()
	{
		return _type;
	}

	//------------------------------------------------------------------------------
	//	X 좌표 저장
	//------------------------------------------------------------------------------
	void SetX(int x)
	{
		_x = x;
	}

	//------------------------------------------------------------------------------
	//	Y 좌표 저장
	//------------------------------------------------------------------------------
	void SetY(int y)
	{
		_y = y;
	}

	//------------------------------------------------------------------------------
	//	가시성 저장
	//------------------------------------------------------------------------------
	void SetVisible(bool bvisible)
	{
		_bvisible = bvisible;
	}

	//------------------------------------------------------------------------------
	//	X 좌표 반환
	//------------------------------------------------------------------------------
	int GetX()
	{
		return _x;
	}

	//------------------------------------------------------------------------------
	//	Y 좌표 반환
	//------------------------------------------------------------------------------
	int GetY()
	{
		return _y;
	}


	//------------------------------------------------------------------------------
	//	이전 X 좌표 반환
	//------------------------------------------------------------------------------
	int GetPreX()
	{
		return _pre_x;
	}

	//------------------------------------------------------------------------------
	//	이전 Y 좌표 반환
	//------------------------------------------------------------------------------
	int GetPreY()
	{
		return _pre_y;
	}


	//------------------------------------------------------------------------------
	//	이전 X 좌표 저장
	//------------------------------------------------------------------------------
	void SetPreX(int pre_x)
	{
		_pre_x = pre_x;
	}

	//------------------------------------------------------------------------------
	//	이전 Y 좌표 저장
	//------------------------------------------------------------------------------
	void SetPreY(int pre_y)
	{
		_pre_y = pre_y;
	}


	//------------------------------------------------------------------------------
	//	가시성 반환
	//------------------------------------------------------------------------------
	int GetVisible()
	{
		return _bvisible;
	}


};


//------------------------------------------------------------------------------
//	불렛 클래스
//
//	:오브젝트 클래스 상속
//------------------------------------------------------------------------------
class CBullet : public CObject {

private:

	//미사일 타입
	//미사일 패턴과 관련
	BULLET_TYPE _type_bullet;

protected:

	//------------------------------------------------------------------------------
	//  가상 소멸자
	//------------------------------------------------------------------------------
	virtual ~CBullet()
	{
		//아무 행동도 안함
	}

public:

	//------------------------------------------------------------------------------
	//	불렛 생성자
	//
	//	:미사일 타입과 움직이는 방향 설정 
	//------------------------------------------------------------------------------
	CBullet(int x, int y, bool bvisible, BULLET_TYPE type_bullet, DIRECTION_MOVE move_direction) :CObject(x, y, bvisible)
	{
		//모양 설정
		shape[0] = 'B';
		shape[1] = '\0';

		_type_bullet = type_bullet;

		//총알 이동 방향
		_last_move_direction = move_direction;

		//오브젝트 타입 형식 불렛 저장
		_type = C_BULLET;
	}


	//------------------------------------------------------------------------------
	//	미사일 타입 반환
	//------------------------------------------------------------------------------
	BULLET_TYPE GetBulletType()
	{
		return _type_bullet;
	}


	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스1 구현
	//
	//	:미사일 타입과 미사일 방향에 따라 현 오브젝트 좌표 값 변경
	//	:불렛이 화면 범위 벗어난 경우 true 반환
	//	:불렛이 화면 범위를 벗어나지 않은 경우 false 반환
	//------------------------------------------------------------------------------
	virtual bool Action()
	{


		//------------------------------------------------------------------------------
		//	현재 좌표 저장
		//------------------------------------------------------------------------------
		int now_x = GetX();
		int now_y = GetY();


		//------------------------------------------------------------------------------
		//	이전 좌표 저장
		//------------------------------------------------------------------------------
		int pre_x = now_x;
		int pre_y = now_y;
		SetPreX(pre_x);
		SetPreY(pre_y);


		//------------------------------------------------------------------------------
		//	외부 전역 외부 변수 선언
		//------------------------------------------------------------------------------
		extern CList<CObject*> g_list_object;
		extern char g_buffer[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
		extern CList<CObject*>::iterator* g_buf_iter[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
		extern CList<CObject*>::iterator current_iter;


		//------------------------------------------------------------------------------
		//	현재 오브젝트 이동 방향에 따른 이동 좌표 계산
		//------------------------------------------------------------------------------
		switch (_type_bullet)
		{
		//직진 방향
		case STRAIGHT:
			//불렛 방향이 왼쪽인 경우
			if (_last_move_direction == DIRECTION_MOVE::MOVE_LEFT)
			{
				now_x += -1;
			}


			//불렛 방향이 오른쪽인 경우
			else if (_last_move_direction == DIRECTION_MOVE::MOVE_RIGHT)
			{
				now_x += +1;
			}

		}


		//------------------------------------------------------------------------------
		//	이동한 오브젝트 좌표 재설정
		//------------------------------------------------------------------------------
		SetX(now_x);
		SetY(now_y);


		//------------------------------------------------------------------------------
		//	불렛이 화면을 벗어나는 경우 체크
		//
		//	:벗어나는 경우 해당 객체 삭제 
		//------------------------------------------------------------------------------
		if (!CheckRangeX(now_x) || !CheckRangeY(now_y))
		{

			//현재 오브젝트 삭제
			current_iter = g_list_object.erase(current_iter);
			return true;
		}




		//------------------------------------------------------------------------------
		//	충돌 조건이지만 이전 오브젝트가 패스한 경우 체크
		//------------------------------------------------------------------------------
		if (g_buffer[pre_y][pre_x] != '\0')
		{
				//기존 좌표 오브젝트 이터레이터 가져옴
				CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[pre_y][pre_x]);

				//기존 오브젝트 반환
				CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

				int obj_same_coordinate_pre_x = obj_same_coordinate->GetPreX();
				int obj_same_coordinate_pre_y = obj_same_coordinate->GetPreY();

				int obj_same_coordinate_now_x = obj_same_coordinate->GetX();
				int obj_same_coordinate_now_y = obj_same_coordinate->GetY();


				//------------------------------------------------------------------------------
				//	충돌 판정
				//------------------------------------------------------------------------------
				if (now_x == obj_same_coordinate_pre_x && now_y == obj_same_coordinate_pre_y &&
					pre_x == obj_same_coordinate_now_x && pre_y == obj_same_coordinate_now_y
					)
				{
						//------------------------------------------------------------------------------
						//	충돌 판정
						//------------------------------------------------------------------------------

						//기존 오브젝트 파괴
						obj_same_coordinate->Destroy();


						//현재 이터레이터를 지우고 다음 이터레이터를 가리키게 만듬
						current_iter = g_list_object.erase(current_iter);

							
						return true;
				}
		}


		


		//------------------------------------------------------------------------------
		//	현재 좌표에 기존 오브젝트가 존재하는 여부 체크
		//------------------------------------------------------------------------------
		if (g_buffer[now_y][now_x] == '\0')
		{
				//현재 좌표에 어떠한 오브젝트도 존재하지 않는 경우

				//출력 버퍼에 표시
				g_buffer[now_y][now_x] = 'B';


				//이터 버퍼에 표시
				CList<CObject*>::iterator *new_ptr_iter = new CList<CObject*>::iterator;
				new_ptr_iter->SetNode2( current_iter.GetNode2() );
				g_buf_iter[now_y][now_x] = new_ptr_iter;

				return false;
		}

		//------------------------------------------------------------------------------
		//	:현재 버퍼 좌표 위치에 기존 오브젝트가 존재하는 경우
		//------------------------------------------------------------------------------
		else if(g_buffer[now_y][now_x] != '\0')
		{

			//기본 오브젝트 이터레이터 가져옴
			CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[now_y][now_x]);

			//기존 오브젝트 반환
			CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

			//기존 오브젝트 파괴
			obj_same_coordinate->Destroy();
			
			//현재 이터 지움
			current_iter =g_list_object.erase(current_iter);

			return true;


		}


	}


	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스2 구현
	//
	//	사용 안함
	//------------------------------------------------------------------------------
	virtual bool Action(CBullet **out_make_bullet)
	{
		return false;
	}



};

//------------------------------------------------------------------------------
//	유닛 클래스
//
//	:오브젝트 클래스 상속
//	:_hp와 움직임 설정 및 불렛 객체 생성 가능
//------------------------------------------------------------------------------
class CUnit : public CObject {

private:

	int _hp;	//체력
	UNIT_TYPE _type_unit;	//유닛 타입

	bool _is_ready_shoot; //총 쏠 준비 여부


	//extern CCircleQueue<COMMAND_PLAYER> g_player_msg; -->질문


	//------------------------------------------------------------------------------
	//	유닛 크기 높이, 너비 변수
	//------------------------------------------------------------------------------
	int _sz_unit_height;
	int _sz_unit_width;

	//------------------------------------------------------------------------------
	//	유닛 모양 변수
	//------------------------------------------------------------------------------
	char _unit_shape[10];

	//------------------------------------------------------------------------------
	//	킬 카운트 변수
	//------------------------------------------------------------------------------
	int _cnt_kill;


protected:

	//------------------------------------------------------------------------------
	//	가상 소멸자
	//------------------------------------------------------------------------------
	virtual ~CUnit()
	{

	}



public:

	//------------------------------------------------------------------------------
	//	유닛 생성자 디폴트
	//
	//	:유닛 기본 크기는 높이, 너비 각각1 초기화
	//	:체력, 타입, 킬 카운트 초기화
	//------------------------------------------------------------------------------
	CUnit(const char *unit_shape, int x, int y, bool bvisible, int hp, UNIT_TYPE type_unit) : CObject(x, y, bvisible)
	{
		_hp = hp;
		_type_unit = type_unit;

		_cnt_kill = 0;

		_sz_unit_height = 1;
		_sz_unit_width = 1;

		_is_ready_shoot = false;

		shape[0] = '\0';

		_last_move_direction = MOVE_STOP;

		//유닛 모양 문자 저장
		if (type_unit == UNIT_TYPE::PLAYER)
		{
			_unit_shape[0] = 'P';
		}
		else if (type_unit == UNIT_TYPE::ENERMY)
		{
			_unit_shape[0] = 'E';
		}

		//타입 결정
		_type = C_UNIT;
	}


	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스1
	//
	//	:불렛 클래스에서 이용 시 
	//------------------------------------------------------------------------------
	virtual bool Action() = 0;


	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스2
	//
	//	플레이어 클래스와 에너미 클래스에서 이용 시
	//------------------------------------------------------------------------------
	virtual bool Action(CBullet **out_make_bullet) = 0;


	//------------------------------------------------------------------------------
	//	총 쏠 여부 검사
	//------------------------------------------------------------------------------
	bool IsReadyShoot()
	{
		//총 발사 여부 체크

		//총 발사 여부 반환
		if (true == _is_ready_shoot)
		{
			//발사 후 원상태로 변경
			_is_ready_shoot = false;
			return true;
		}
		else
			return false;

	}

	//------------------------------------------------------------------------------
	//	hp 반환 함수
	//------------------------------------------------------------------------------
	int getHp()
	{
		return _hp;
	}


	//------------------------------------------------------------------------------
	//	hp 설정 함수
	//------------------------------------------------------------------------------
	void SetHp(int hp)
	{
		_hp = hp;;
	}

	//------------------------------------------------------------------------------
	//	유닛 타입 반환
	//------------------------------------------------------------------------------
	UNIT_TYPE Get_Type()
	{
		return _type_unit;
	}

	//------------------------------------------------------------------------------
	//	_hp 감소 함수
	//
	//	:hp가 0보다 적을 때 true 반환
	//------------------------------------------------------------------------------
	bool DecreaseHp()
	{
		_hp--;

		if (_hp == 0)
		{
			SetVisible(false);
			return true;
		}

		return false;
	}


	//------------------------------------------------------------------------------
	//	_cnt_kill 증가
	//------------------------------------------------------------------------------
	void IncreaseCntKill()
	{
		_cnt_kill++;
	}

	//------------------------------------------------------------------------------
	//	cntCnt Kill 반환
	//------------------------------------------------------------------------------
	int GetCntKill()
	{
		return _cnt_kill;
	}


	//------------------------------------------------------------------------------
	//	유닛 높이 반환
	//------------------------------------------------------------------------------
	int GetSzUnitHeight()
	{
		return _sz_unit_height;
	}


	//------------------------------------------------------------------------------
	//	유닛 너비 반환
	//------------------------------------------------------------------------------
	int GetSzUnitWidth()
	{
		return _sz_unit_width;
	}

	//------------------------------------------------------------------------------
	//	유닛 모양 반환
	//------------------------------------------------------------------------------
	char* GetUnitShape()
	{
		return _unit_shape;
	}

};



//------------------------------------------------------------------------------
//	플레이어 클래스
//
//	:플레이어 클래스 상속
//	:가상 함수 Action() 구현
//------------------------------------------------------------------------------
class CPlayer : public CUnit {

protected:

	//------------------------------------------------------------------------------
	//	가상 소멸자
	//------------------------------------------------------------------------------
	virtual ~CPlayer()
	{
		//아무것도 안함
	}

public:

	//현재 플레이어 넘버
	//어떻게 상수형식으로 받을 수 있을까??
	NUM_PLAYER _current_player;


	//------------------------------------------------------------------------------
	//	생성자
	//------------------------------------------------------------------------------
	CPlayer(NUM_PLAYER current_player, const char *unit_shape, int x, int y, bool bvisible, int hp, UNIT_TYPE type_unit)  : CUnit(unit_shape, x, y, bvisible, hp, type_unit)
	{
		_current_player = current_player;

		//모양 설정
		shape[0] = unit_shape[0];
		shape[1] = '\0';

		//타입 결정
		_type = C_PLAYER;
	}


	//------------------------------------------------------------------------------
	//	플레이어 객체 움직임 함수
	//	가상 함수 구현
	//------------------------------------------------------------------------------
	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스1
	//------------------------------------------------------------------------------
	virtual bool Action(CBullet **out_make_bullet)
	{
		extern CList <play_info_msg> g_player_msg[2];

		return true;
	}

	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스2
	//
	//	플레이어 클래스와 에너미 클래스에서 이용 시
	//------------------------------------------------------------------------------
	virtual bool Action()
	{
		//------------------------------------------------------------------------------
		//	외부 전역 메시지 리스트 
		//------------------------------------------------------------------------------
		extern CList <play_info_msg> g_player_msg[2];
		
		int num_player = -1;
		

		//------------------------------------------------------------------------------
		//	현재 플레이어 객체 플레이어 번호 추출
		//------------------------------------------------------------------------------
		if (_current_player == NUM_PLAYER::FIRST_PLAYER)
		{
			num_player = 0;
		}
		else if (_current_player == NUM_PLAYER::SECOND_PLAYER)
		{
			num_player = 1;
		}


		//------------------------------------------------------------------------------
		//	현재 좌표  저장
		//------------------------------------------------------------------------------
		int now_x = GetX();
		int now_y = GetY(); 


		//이동 거리
		int inc_x = 0;
		int inc_y = 0;


		//------------------------------------------------------------------------------
		//	이전 좌표 저장
		//------------------------------------------------------------------------------
		int pre_x = now_x;
		int pre_y = now_y;



		//샷 여부 체크 플래그
		bool shoot_flag = false;

		//다음 이터로 넘기는 여부 체크 플래그
		bool next_iter_flag = false;




		//------------------------------------------------------------------------------
		//	외부 전역 외부 변수 선언
		//------------------------------------------------------------------------------
		extern CList<CObject*> g_list_object;
		extern char g_buffer[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
		extern CList<CObject*>::iterator* g_buf_iter[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
		extern CList<CObject*>::iterator current_iter;


		//------------------------------------------------------------------------------
		//	메시지 이터레이터 초기화
		//------------------------------------------------------------------------------
		COMMAND_PLAYER now_msg;
		play_info_msg current_input_key;
		CList<play_info_msg>::iterator idx_iter = g_player_msg[num_player].begin();


		//------------------------------------------------------------------------------
		//	키 입력에 의한 플레이어 객체 동작
		//------------------------------------------------------------------------------
		while (false == g_player_msg[num_player].is_empty())
		{

			//초기화
			inc_x = 0;
			inc_y = 0;

			//------------------------------------------------------------------------------
			//	입력 키 추출
			//------------------------------------------------------------------------------
			current_input_key = *idx_iter;
			idx_iter=g_player_msg[num_player].erase(idx_iter);
			now_msg = current_input_key.msg;


			//------------------------------------------------------------------------------
			//	키 입력에 따른 플레이어 오브젝트 설정
			//------------------------------------------------------------------------------
			switch (now_msg)
			{
			case KEY_UP:
				inc_y--;
				break;


			case KEY_DOWN:
				inc_y++;
				break;


			case KEY_LEFT:
				inc_x--;
				break;


			case KEY_RIGHT:
				inc_x++;
				break;


			case KEY_SPACE:
				shoot_flag = true;
				break;
			}


			//------------------------------------------------------------------------------
			//	:플레이어 오브젝트가 화면을 벗어나는 경우 체크
			//------------------------------------------------------------------------------
			if (!CheckRangeX(now_x + inc_x) || !CheckRangeY(now_y + inc_y))
			{
				continue;
			}


			//------------------------------------------------------------------------------
			//	오브젝트 간 충돌 여부 판단
			//
			//	:이동 후 좌표에 유저와 에너미가 존재하는 경우 이동 할 수 없다
			//------------------------------------------------------------------------------
			if (g_buffer[now_y + inc_y][now_x + inc_x] == 'E' ||
				g_buffer[now_y + inc_y][now_x + inc_x] == 'P'
				)
			{
				continue;

			}
			

			//이전 좌표 저장
			pre_x = now_x;
			pre_y = now_y;


			//이동 후 좌표 저장
			now_x = now_x + inc_x;
			now_y = now_y + inc_y;
			
			
		}//반복문



		//------------------------------------------------------------------------------
		//	불렛 발사 여부 체크
		//------------------------------------------------------------------------------
		if (true == shoot_flag)
		{
			//불렛 객체 생성
			CBullet * new_bullet = new CBullet(now_x, now_y, true, BULLET_TYPE::STRAIGHT, DIRECTION_MOVE::MOVE_LEFT);
			g_list_object.push_back(new_bullet);

			//현재 같은 좌표 이터레이터 가져옴
			//이터 버퍼에 표시
			CList<CObject*>::iterator *new_ptr_iter = new CList<CObject*>::iterator;
			*new_ptr_iter = g_list_object.GetLastIter();
			g_buf_iter[now_y][now_x] = new_ptr_iter;


			next_iter_flag = true;
		}



		//------------------------------------------------------------------------------
		//	충돌 조건이지만 이전 오브젝트가 패스한 경우 체크
		//------------------------------------------------------------------------------
		if (g_buffer[pre_y][pre_x] == 'B')
		{
			//기존 좌표 오브젝트 이터레이터 가져옴
			CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[pre_y][pre_x]);

			//기존 오브젝트 반환
			CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

			//기존 오브젝트 타입 반환
			TYPE_OBJECT type_same_coordinate_obj = obj_same_coordinate->GetType();

			int obj_same_coordinate_pre_x = obj_same_coordinate->GetPreX();
			int obj_same_coordinate_pre_y = obj_same_coordinate->GetPreY();

			int obj_same_coordinate_now_x = obj_same_coordinate->GetX();
			int obj_same_coordinate_now_y = obj_same_coordinate->GetY();


			//------------------------------------------------------------------------------
			//	충돌 판정
			//
			//	:obj_same_coordinate_obj가 불렛 타입일 때만 해당
			//------------------------------------------------------------------------------
			if (now_x== obj_same_coordinate_pre_x && now_y == obj_same_coordinate_pre_y &&
				pre_x == obj_same_coordinate_now_x && pre_y == obj_same_coordinate_now_y
				//&&
				//type_same_coordinate_obj == TYPE_OBJECT::C_BULLET
				)
			{
				//------------------------------------------------------------------------------
				//	충돌 판정
				//------------------------------------------------------------------------------

				//기존 오브젝트 파괴
				obj_same_coordinate->Destroy();


				//현재 이터레이터를 지우고 다음 이터레이터를 가리키게 만듬
				current_iter = g_list_object.erase(current_iter);


				return true;
			}
		}



		//------------------------------------------------------------------------------
		//	오브젝트 간 충돌 여부 판단
		//
		//	:현재 오브젝트의 이동 후 좌표값으로 이동 가능 여부 체크 
		//------------------------------------------------------------------------------
		if (g_buffer[now_y][now_x] =='B')
		{
			//같은 좌표 내 기존 오브젝트 이터레이터 가져옴
			CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[now_y][now_x ]);

			//기존 오브젝트 반환
			CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

			//기존 오브젝트 타입 반환
		//	TYPE_OBJECT type_same_coordinate_obj = obj_same_coordinate->GetType();



			//같은 좌표 내 기존 오브젝트 타입이 불렛인 경우
			//둘 다 파괴되어야 한다
			//if (g_buffer[now_y][now_x] =='B')
				//type_same_coordinate_obj == TYPE_OBJECT::C_BULLET)
			//{
				//형변환
				CBullet *bullet_same_coordinate = (CBullet *)obj_same_coordinate;

				//기존 오브젝트 방향 저장
				DIRECTION_MOVE direction_same_coordinate_obj;
				direction_same_coordinate_obj = bullet_same_coordinate->GetDirectionMove();


				//기존 오브젝트 파괴
				obj_same_coordinate->Destroy();

				//현재 이터 지움
				current_iter = g_list_object.erase(current_iter);
				return true;


			//}

		}

		//------------------------------------------------------------------------------
		//	현재 해당 오브젝트를 출력 버퍼 및 이터 버퍼에 저장
		//------------------------------------------------------------------------------
		CList<CObject*>::iterator *new_ptr_iter = new CList<CObject*>::iterator;
		new_ptr_iter->SetNode2(current_iter.GetNode2());
		g_buf_iter[now_y][now_x] = new_ptr_iter;

	  
		g_buffer[now_y][now_x] = 'P';

		//좌표 재설정
		SetX(now_x);
		SetY(now_y);

		SetPreX(pre_x);
		SetPreY(pre_y);


		//------------------------------------------------------------------------------
		//	다음 이터로 넘김 여부 체크 후 리턴 값 반환
		//------------------------------------------------------------------------------
		if( true == next_iter_flag)
			return true;
		else
			return false;

	}
};


//------------------------------------------------------------------------------
//	적 클래스
//
//	:플레이어 클래스 상속
//	:가상 함수 Action() 구현
//------------------------------------------------------------------------------
class CEnermy : public CUnit {
protected:
	virtual ~CEnermy()
	{
		//아무것도 안함
	}
public:

	//패턴 상수
	int _pattern_act;

	//------------------------------------------------------------------------------
	//	생성자
	//------------------------------------------------------------------------------
	CEnermy(const char *unit_shape, int x, int y, bool bvisible, int hp, UNIT_TYPE type_unit) : CUnit(unit_shape, x, y, bvisible, hp, type_unit)
	{
		_pattern_act = 0;

		//모양 설정
		shape[0] = unit_shape[0];
		shape[1] = '\0';

		//유닛 타입
		_type = C_ENERMY;
	}

	//------------------------------------------------------------------------------
	//	에너미 객체 움직임 함수
	//	가상 함수 구현
	//------------------------------------------------------------------------------
	//------------------------------------------------------------------------------
	//	가상 함수 인터페이스1
	//------------------------------------------------------------------------------
	virtual bool Action()
	{

			//------------------------------------------------------------------------------
			//	현재 좌표 저장
			//------------------------------------------------------------------------------
			int now_x = GetX();
			int now_y = GetY();


			//------------------------------------------------------------------------------
			//	이전 좌표 저장
			//------------------------------------------------------------------------------
			int pre_x = now_x;
			int pre_y = now_y;
			SetPreX(pre_x);
			SetPreY(pre_y);


			//이동 좌표 거리
			int inc_x = 0;
			int inc_y = 0;

			//전역 외부 설정
			extern CList<CObject*> g_list_object;
			extern char g_buffer[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
			extern CList<CObject*>::iterator* g_buf_iter[SIZE_PLAY_SCREEN::PLAY_SCREEN_HEIGHT][SIZE_PLAY_SCREEN::PLAY_SCREEN_WIDTH];
			extern CList<CObject*>::iterator current_iter;

			//샷 여부 플래그
			bool shoot_flag = false;

			//마지막 움직임 방향 저장
			DIRECTION_MOVE last_move_direction=MOVE_STOP;

			//------------------------------------------------------------------------------
			//	패턴에 따른 에너미 오브젝트 설정
			//------------------------------------------------------------------------------
			switch (_pattern_act)
			{

				//위로 이동
			case 1:
				//좌표 이동
				inc_y--;
				last_move_direction = MOVE_UP;
				break;

				//아래로 이동
			case 5:
				//좌표 이동
				inc_y++;
				last_move_direction = MOVE_DOWN;
				break;

				//총 발사
			case 10:
				shoot_flag = true;
				last_move_direction = MOVE_STOP;
				break;

			//좌로 이동
			case 14:
				//좌표 이동
				inc_x--;
				last_move_direction = MOVE_LEFT;
				break;

			//우로 이동
			case 19:
				//좌표 이동
				inc_x++;
				last_move_direction = MOVE_RIGHT;
				break;
			}
			

			//------------------------------------------------------------------------------
			//	패턴 재 설정
			//------------------------------------------------------------------------------
			_pattern_act++;
			if (_pattern_act % 20 == 0)
			{
				_pattern_act = 0;
			}


			//------------------------------------------------------------------------------
			//	충돌 조건이지만 이전 오브젝트가 패스한 경우 체크
			//------------------------------------------------------------------------------
			if (g_buffer[pre_y][pre_x] == 'B')
			{
				//기존 좌표 오브젝트 이터레이터 가져옴
				CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[pre_y][pre_x]);

				//기존 오브젝트 반환
				CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

				//기존 오브젝트 타입 반환
				TYPE_OBJECT type_same_coordinate_obj = obj_same_coordinate->GetType();

				int obj_same_coordinate_pre_x = obj_same_coordinate->GetPreX();
				int obj_same_coordinate_pre_y = obj_same_coordinate->GetPreY();

				int obj_same_coordinate_now_x = obj_same_coordinate->GetX();
				int obj_same_coordinate_now_y = obj_same_coordinate->GetY();


				//------------------------------------------------------------------------------
				//	충돌 판정
				//
				//	:obj_same_coordinate_obj가 불렛 타입일 때만 해당
				//------------------------------------------------------------------------------
				if (now_x == obj_same_coordinate_pre_x && now_y == obj_same_coordinate_pre_y &&
					pre_x == obj_same_coordinate_now_x && pre_y == obj_same_coordinate_now_y
					&&
					type_same_coordinate_obj== TYPE_OBJECT::C_BULLET
					)
				{
					//------------------------------------------------------------------------------
					//	충돌 판정
					//------------------------------------------------------------------------------

					//기존 오브젝트 파괴
					obj_same_coordinate->Destroy();


					//현재 이터레이터를 지우고 다음 이터레이터를 가리키게 만듬
					current_iter = g_list_object.erase(current_iter);


					return true;
				}
			}



			//불렛 발사
			if (true == shoot_flag)
			{
				//불렛 객체 생성
				CBullet * new_bullet = new CBullet(now_x, now_y, true, BULLET_TYPE::STRAIGHT, DIRECTION_MOVE::MOVE_LEFT);
				g_list_object.push_back(new_bullet);

				//현재 같은 좌표 이터레이터 가져옴
				//이터 버퍼에 표시
				CList<CObject*>::iterator *new_ptr_iter = new CList<CObject*>::iterator;
				*new_ptr_iter = g_list_object.GetLastIter();
				g_buf_iter[now_y][now_x] = new_ptr_iter;

				return true;
			}



			//------------------------------------------------------------------------------
			//	:오브젝트가 화면을 벗어나는 경우 체크
			//------------------------------------------------------------------------------
			if (!CheckRangeX(now_x+inc_x) || !CheckRangeY(now_y + inc_y))
			{
				//움직이지 않은 상태 저장
				_last_move_direction = MOVE_STOP;
				return false;
			}


			//------------------------------------------------------------------------------
			//	오브젝트 간 충돌 여부 판단
			//
			//	:현재 오브젝트의 이동 후
			//------------------------------------------------------------------------------
			if (g_buffer[now_y + inc_y][now_x + inc_x] != '\0')
			{
				//기존 오브젝트 이터레이터 가져옴
				CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[now_y + inc_y][now_x + inc_x]);

				//기존 오브젝트 반환
				CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

				//기존 오브젝트 타입 반환
				TYPE_OBJECT type_same_coordinate_obj = obj_same_coordinate->GetType();



				//------------------------------------------------------------------------------
				//	기존 좌표 오브젝트 타입이 불렛인 경우
				//
				//	:기존 좌표 오브젝트와 현재 오브젝트 둘 다 파괴
				//------------------------------------------------------------------------------
				if (type_same_coordinate_obj == TYPE_OBJECT::C_BULLET)
				{

					//불렛 형 변환
					CBullet *bullet_same_coordinate = (CBullet *)obj_same_coordinate;

					//기존 오브젝트 방향 저장
					DIRECTION_MOVE direction_same_coordinate_obj;
					direction_same_coordinate_obj = bullet_same_coordinate->GetDirectionMove();

					//현재 오브젝트 이동 방향 저장
					DIRECTION_MOVE direction_current_obj;
					direction_current_obj = this->GetDirectionMove();


					//기본 오브젝트 이터레이터 가져옴
					CList<CObject*>::iterator ptr_same_coordinate_iter = *(g_buf_iter[now_y][now_x]);

					//기존 오브젝트 반환
					CObject *obj_same_coordinate = *(ptr_same_coordinate_iter);

					//기존 오브젝트 파괴
					obj_same_coordinate->Destroy();

					//현재 이터 지움
					current_iter = g_list_object.erase(current_iter);
					return true;


				}
				//------------------------------------------------------------------------------
				//	적 혹은 주인공 물체와 겹치는 경우
				//
				//	:이동을 안함
				//------------------------------------------------------------------------------
				else
				{
					//------------------------------------------------------------------------------
					//	이동한 오브젝트 좌표 재설정
					//------------------------------------------------------------------------------
					SetX(now_x);
					SetY(now_y);
				}
			}//오브젝트 간 충돌 체크 끝


			 //------------------------------------------------------------------------------
			 //	오브젝트 간 좌표 상 겹쳐지지 않는 경우
			 //
			 // :현재 해당 오브젝트 이동
			 //------------------------------------------------------------------------------
			else
			{
				//------------------------------------------------------------------------------
				//	이동한 오브젝트 좌표 재설정
				//------------------------------------------------------------------------------
				SetX(now_x + inc_x);
				SetY(now_y + inc_y);
			}


			//------------------------------------------------------------------------------
			//	로직 후 이동 좌표 재 저장
			//------------------------------------------------------------------------------
			now_x = GetX();
			now_y = GetY();


			//------------------------------------------------------------------------------
			//	현재 해당 오브젝트를 출력 버퍼 및 이터 버퍼에 저장
			//------------------------------------------------------------------------------
			CList<CObject*>::iterator *new_ptr_iter = new CList<CObject*>::iterator;
			new_ptr_iter->SetNode2(current_iter.GetNode2());
			g_buf_iter[now_y][now_x] = new_ptr_iter;

			//버퍼에 그리기
			g_buffer[now_y][now_x] = 'E';

			return false;
		
		}

		//------------------------------------------------------------------------------
		//	가상 함수 인터페이스2
		//
		//	플레이어 클래스와 에너미 클래스에서 이용 시
		//------------------------------------------------------------------------------
		virtual bool Action(CBullet **out_make_bullet)
		{
			//구현 안함
			return true;
		
	}


};