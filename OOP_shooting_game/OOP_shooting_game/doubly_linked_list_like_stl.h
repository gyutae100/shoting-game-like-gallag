#pragma once

#include <iostream>
using namespace std;


//------------------------------------------------------------------------------
//	템플릿 리스트 클래스
//	
//	:이터레이터와 합성관계
//	:이터레이터 연산자 오버로딩 지원
//------------------------------------------------------------------------------
template <typename T>
class CList
{
public:

	//------------------------------------------------------------------------------
	//	노드 구조체
	//	
	//	:리스트 각 노드
	//	:이터레이터와 합성관계
	//------------------------------------------------------------------------------
	struct Node
	{
		//------------------------------------------------------------------------------
		//	주의
		//
		//	:T _data를 T *_data *형식으로 하지 말 것.
		//	:만일 *형식으로 설정하고 싶으면 차라리 클래스 생성시 템플릿 인자를 *로 할 것.
		//
		//	:이유
		//	:	변수 시에는 그냥 저장하면 _data에 저장하면 됨
		//	:	크기가 큰 클래스는 T타입을 포인터로 받으면 됨.
		//------------------------------------------------------------------------------
		T _data;
		Node *_Prev;
		Node *_Next;
	};


	//------------------------------------------------------------------------------
	//	이터레이터 클래스
	//
	//	:노드 구조체와 합성관계	
	//	:노드 구조체에 여러 오버로딩 지원 가능
	//	:리스트 요소 순회 시 현재 방문 중인 노드를 클래스 바깥으로 빼서 보관 할 수 있다. (이는 1개 이상 가능)
	//	:기존 방식인 클래스 내 하나의 현재 방문 중인 노드 포인터로는 하나의 현재 방문 요소만 저장 가능. (이는 1개만 가능)
	//------------------------------------------------------------------------------
	class iterator
	{


	private:

		//------------------------------------------------------------------------------
		//	이터레이터 데이터 값
		//------------------------------------------------------------------------------
		Node * _node;


		//------------------------------------------------------------------------------
		//	이터레이터 값 반환
		//------------------------------------------------------------------------------
		Node* GetNode()
		{
			return _node;
		}

		//------------------------------------------------------------------------------
		//	프랜드 선언
		//
		//	:합성 관계
		//------------------------------------------------------------------------------
		friend class CList;

	public:

		//------------------------------------------------------------------------------
		//	생성자
		//------------------------------------------------------------------------------
		iterator(Node *node = nullptr)
		{
			//인자로 들어온 Node 포인터를 저장
			_node = node;
		}

		void SetNode2(Node* node)
		{
			_node = node;
		}

		Node* GetNode2()
		{
			return _node;
		}



		//------------------------------------------------------------------------------
		//	후위 증가 연산자
		//------------------------------------------------------------------------------
		iterator operator ++(int)
		{
			//반환 리터 선언 및 초기화
			iterator out_iter(_node);

			//현재 노드를 다음 노드로 이동
			_node = _node->_Next;

			return out_iter;
		}

		//------------------------------------------------------------------------------
		//	후위 감소 연산자
		//------------------------------------------------------------------------------
		iterator operator --(int)
		{

			//반환 리터 선언 및 초기화
			iterator out_iter(_node);

			//현재 노드를 다음 노드로 이동
			_node = _node->_Prev;

			return out_iter;
		}


		//------------------------------------------------------------------------------
		//	전위 증가 연산자
		//------------------------------------------------------------------------------
		iterator operator ++()
		{
			//현재 이터레이터가 테일 더미 인 경우
			if (_node->_Next == NULL)
			{
				return *this;
			}
			//현재 노드를 다음 노드로 이동
			else
				_node = _node->_Next;

			return *this;
		}

		//------------------------------------------------------------------------------
		//	전위 감소 연산자
		//------------------------------------------------------------------------------
		iterator operator --()
		{
			//현재 이터레이터가 헤드 더미 인 경우
			if (_node->_Prev == NULL)
			{
				return *this;
			}
			//현재 노드를 다음 노드로 이동
			else
				_node = _node->_Prev;

			return *this;
		}


		//------------------------------------------------------------------------------
		//	* 연산자
		//
		//	:이터레이터 데이터 값 반환 
		//------------------------------------------------------------------------------
		T& operator *()
		{
			//현재 노드의 데이터를 뽑음
			return _node->_data;
		}


		//------------------------------------------------------------------------------
		//	== 비교 연산자 
		//------------------------------------------------------------------------------
		bool operator ==(const iterator target)
		{
			return (_node == target._node);
		}


		//------------------------------------------------------------------------------
		//	!= 비교 연산자2 
		//------------------------------------------------------------------------------
		bool operator !=(const iterator target)
		{
			return !(*this == target);
		}


		//------------------------------------------------------------------------------
		//	= 대입 연산자
		//------------------------------------------------------------------------------
		iterator& operator =(const iterator& target)
		{
			_node = target._node;
			return *this;
		}

	};

public:
	CList()
	{

		//헤드 더미 노드 생성 및 초기화
		_head = *(new Node);
		//_head._data = 0;
		_head._Prev = NULL;
		_head._Next = NULL;

		//테일 더미 노드 생성 및 초기화
		_tail = *(new Node);
		//_tail._data = 0;
		_tail._Prev = NULL;
		_tail._Next = NULL;

		//헤드 더미 노드와 테일 더미 노드 연결
		//아무 요소도 없는 경우
		_head._Next = &(_tail);
		_tail._Prev = &(_head);

		//노드 사이즈 0
		_size = 0;


	}

	~CList()
	{
		Node * current_node = _head._Next;
		Node * prev_node = current_node;

		//순회하며 순차적 삭제
		while (!current_node->_Next != NULL)
		{
			prev_node = current_node;
			current_node = current_node->_Next;
			delete(prev_node);
		}

		_size = 0;
	}


	//------------------------------------------------------------------------------
	//	시작 이터레이터 반환
	//
	//	:만일 노드가 존재하지 않으면 헤드 더미 노드 반환
	//	:노드가 1개 이상 존재시 첫 번째 노드 반환
	//------------------------------------------------------------------------------
	iterator begin()
	{
		//노드가 존재하지 않는 경우
		if (true == is_empty())
		{
			iterator new_iter = iterator(&_head);
			return new_iter;
		}
		//요소가 1개 이상 존재하는 경우
		else
		{
			iterator new_iter = iterator(_head._Next);
			return new_iter;
		}

	}


	//------------------------------------------------------------------------------
	//	마지막 이터레이터 반환
	//
	//	:무조건 테일 더미 노드 반환
	//------------------------------------------------------------------------------
	iterator end()
	{
		//반환 이터레이터 선언 및 테일 더미 노드로 초기화
		iterator new_iter = iterator(&_tail);
		return new_iter;
	}

	//------------------------------------------------------------------------------
	//	마지막 이터레이터 반환
	//
	//	:무조건 테일 더미 노드 반환
	//------------------------------------------------------------------------------
	iterator GetLastIter()
	{
		//반환 이터레이터 선언 및 테일 더미 노드로 초기화
		Node *tmp = _tail._Prev;
		iterator new_iter = iterator(tmp);
		return new_iter;
	}


	//------------------------------------------------------------------------------
	//	이터레이터 지우기
	//
	//	:이터레이터 내부 노드 지움
	//	:지운 노드의 다음 노드를 가리키는 이터레이터 반환
	//------------------------------------------------------------------------------
	iterator erase(iterator itor)
	{
		//삭제 노드
		Node *delete_node = itor.GetNode();

		//삭제 노드 이전 노드와 이후 노드 선언
		Node *prev_node = delete_node->_Prev;
		Node *next_node = delete_node->_Next;

		if (delete_node == NULL)
		{
			return itor;
		}


		//헤드 더미 또는 테일 더미 여부 검사
		if (prev_node == NULL || next_node == NULL)
		{
			return itor;
		}

		_size--;


		//이전 노드와 이후 노드 간 연결
		prev_node->_Next = next_node;
		next_node->_Prev = prev_node;


		//반환 이터는 삭제 노드의 다음 노드를 가리킴
		//프렌드 이므로 프라이빗 멤버 _node 접근 가능
		itor++;

		delete(delete_node);

		//반환
		return itor;


	}

	//------------------------------------------------------------------------------
	//	인터페이스 함수 목록
	//------------------------------------------------------------------------------
	void push_front(T data) //첫 번째 노드로 추가
	{
		//새 삽입 노드 생성
		Node * new_node = new Node();
		new_node->_data = data;

		//연결 설정
		_head._Next->_Prev = new_node;
		new_node->_Next = _head._Next;

		new_node->_Prev = &(_head);
		_head._Next = new_node;


		//노드 사이즈 증가
		_size++;
	}

	void push_back(T data) //마지막 노드로 추가
	{
		//새 삽입 노드 생성
		Node * new_node = new Node();
		new_node->_data = data;

		//연결 설정
		_tail._Prev->_Next = new_node;
		new_node->_Prev = _tail._Prev;

		_tail._Prev = new_node;
		new_node->_Next = &(_tail);


		//노드 사이즈 증가
		_size++;
	}



	void clear()
	{
		//방문 노드 생성
		//출력 시작 노드 가리킴
		Node * current_node = _head._Next;

		//커런트 노드 이전 노드 
		Node * prev_node = current_node;
		int idx = 0;

		//순회하며 순차적 삭제
		while (current_node->_Next != NULL)
		{
			idx++;
			prev_node = current_node;
			current_node = current_node->_Next;
			delete(prev_node);

		}

		cout << "total delete:" << idx << endl;



		//헤드 더미 노드와 테일 더미 노드 연결
		//아무 요소도 없는 경우
		_head._Next = &(_tail);
		_tail._Prev = &(_head);





	}
	//모든 노드 삭제
	void DisplayAll()	//모든 노드 출력
	{
		//방문 노드 생성
		//출력 시작 노드 가리킴
		Node * current_node = _head._Next;

		//인덱스 
		int idx = 0;
		//순회 진행 출력
		while (current_node->_Next != NULL)
		{
			cout << "[" << idx++ << "] " << current_node->_data << endl;
			current_node = current_node->_Next;
		}

		//노드 사이즈 0
		_size = 0;

		//출력 하지 못한 경우 == 개수가0개인 경우
		if (idx == 0)
			cout << "empty";


	}
	int size() { return _size; };	//사이즈 반환
	bool is_empty()	//빈 여부 체크
	{
		if (_size == 0)
			return true;
		else
			return false;
	}



private:
	int _size = 0;
	Node _head;
	Node _tail;
};



